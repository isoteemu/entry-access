{{define "head"}}
    <style>
        :root{
            --matrix-glyph-size:12px;
            --matrix-glyph-font-size:12px;
            --matrix-glyph-front-color:rgba(255, 255, 255, 0.9);
            --matrix-glyph-tail-color:#00ff00;
            --matrix-overlay-color:rgba(0, 0, 0, 0.15);
        }
        .matrix-glow {
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
        }
        .border-glow {
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5), inset 0 0 20px rgba(0, 255, 0, 0.1);
        }
        @media screen and (max-width:768px){
            :root{--matrix-glyph-size:8px;--matrix-glyph-font-size:8px;}
        }
    </style>
{{end}}

{{define "content"}}
    <!-- Override the default content structure for full-screen matrix effect -->
{{end}}

{{define "footer-content"}}
    <!-- No footer for this page -->
{{end}}

{{define "scripts"}}
    <!-- Matrix background canvas (positioned absolutely) -->
    <div class="fixed inset-0 z-0">
        <canvas id="matrix" class="w-full h-full"></canvas>
    </div>

    <!-- Content overlay -->
    <div class="fixed inset-0 z-10 flex items-center justify-center p-4">
        <ul id="matrix-words" class="hidden">
            <li>ACCESS</li>
            <li>GRANTED</li>
            <li>{{ .EntryPoint }}</li>
            <li>{{ .UserName }}</li>
            <li>AUTHORIZED</li>
            <li>ENTRY</li>
            <li>SYSTEM</li>
        </ul>

        <div class="bg-black bg-opacity-90 border-2 border-matrix-green border-glow rounded-lg p-8 max-w-md w-full text-center">
            <!-- Success Icon -->
            <div class="mb-6">
                <div class="mx-auto w-20 h-20 bg-matrix-green rounded-full flex items-center justify-center matrix-glow">
                    <svg class="w-12 h-12 text-black" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                    </svg>
                </div>
            </div>

            <!-- Main Message -->
            <h1 class="font-heading text-4xl md:text-5xl font-bold text-matrix-green matrix-glow mb-4">
                ACCESS GRANTED
            </h1>
            
            <p class="text-white text-lg mb-6">
                Welcome, authorization successful
            </p>

            <!-- Details -->
            <div class="space-y-3 text-left">
                {{ if .UserName }}
                <div class="flex justify-between items-center border-b border-matrix-green-dim pb-2">
                    <span class="text-gray-300 text-sm">User:</span>
                    <span class="text-matrix-green font-mono text-sm">{{ .UserName }}</span>
                </div>
                {{ end }}
                
                {{ if .EntryPoint }}
                <div class="flex justify-between items-center border-b border-matrix-green-dim pb-2">
                    <span class="text-gray-300 text-sm">Entry Point:</span>
                    <span class="text-matrix-green font-mono text-sm">{{ .EntryPoint }}</span>
                </div>
                {{ end }}
                
                <div class="flex justify-between items-center border-b border-matrix-green-dim pb-2">
                    <span class="text-gray-300 text-sm">Time:</span>
                    <span class="text-matrix-green font-mono text-sm" id="current-time"></span>
                </div>
                
                {{ if .EntryID }}
                <div class="flex justify-between items-center">
                    <span class="text-gray-300 text-sm">Entry ID:</span>
                    <span class="text-matrix-green font-mono text-xs">{{ .EntryID }}</span>
                </div>
                {{ end }}
            </div>
        </div>
    </div>

    <script>
        // Update current time
        function updateTime() {
            const now = new Date();
            document.getElementById('current-time').textContent = now.toLocaleTimeString();
        }
        updateTime();
        setInterval(updateTime, 1000);

        // Matrix background effect
        'use strict';

        const Matrix = function ($canvas) {
            const symbols = '01アクセス許可システムドアエントリー承認済み'.split('');

            const getRandomSymbol = function () {
                return symbols[Math.floor(Math.random() * symbols.length)];
            }

            const ctx = $canvas.getContext('2d');
            ctx.globalCompositeOperation = 'lighter';

            this.redrawInterval = 100;
            this.glyphSize = 0;
            this.rowsCapacity = 0;
            this.columnsCapacity = 0;

            this.init = () => {
                $canvas.width = $canvas.clientWidth;
                $canvas.height = $canvas.clientHeight;

                this.glyphSize = parseInt(getComputedStyle($canvas).getPropertyValue('--matrix-glyph-size'), 10);
                this.rowsCapacity = Math.ceil($canvas.clientHeight / this.glyphSize);
                this.columnsCapacity = Math.ceil($canvas.clientWidth / this.glyphSize);
            };

            const drawSymbol = (symbol, row, column, color) => {
                if (row > this.rowsCapacity || column > this.columnsCapacity) {
                    return;
                }

                ctx.fillStyle = color;
                ctx.font = getComputedStyle($canvas).getPropertyValue('--matrix-glyph-font-size') + ' monospace';

                if (symbol.length > 1) {
                    symbol = symbol.charAt(0);
                }

                let xOffset = 0, charCode = symbol.charCodeAt(0);
                if (charCode >= 33 && charCode <= 126) {
                    xOffset = this.glyphSize / 5;
                }

                ctx.fillText(symbol, (column * this.glyphSize) + xOffset, row * this.glyphSize);
            };

            const drawLine = (column, speed, text, offset) => {
                let cursor = 0;
                const tailColor = getComputedStyle($canvas).getPropertyValue('--matrix-glyph-tail-color'),
                    frontColor = getComputedStyle($canvas).getPropertyValue('--matrix-glyph-front-color');

                const handler = setInterval(() => {
                    if (column > this.columnsCapacity) {
                        return clearInterval(handler);
                    }

                    if (cursor <= this.rowsCapacity) {
                        let symbol = getRandomSymbol();

                        if (typeof text === 'string' && typeof offset === 'number') {
                            if (cursor >= offset && text.length >= cursor - offset) {
                                symbol = text.charAt(cursor - offset);
                            }
                        }

                        if (typeof symbol === 'string' && symbol !== ' ') {
                            const prev = cursor;
                            setTimeout(() => {
                                drawSymbol(symbol, prev, column, tailColor);
                            }, speed / 1.3);

                            drawSymbol(symbol, cursor, column, frontColor);
                        }
                        cursor++;
                    } else {
                        clearInterval(handler);
                    }
                }, speed);
            };

            this.redraw = () => {
                ctx.fillStyle = getComputedStyle($canvas).getPropertyValue('--matrix-overlay-color');
                ctx.fillRect(0, 0, $canvas.clientWidth, $canvas.clientHeight);
            };

            let redrawIntervalHandler, dropsIntervalHandler;

            this.run = ($linesList) => {
                if (!redrawIntervalHandler) {
                    redrawIntervalHandler = setInterval(this.redraw, this.redrawInterval);
                }

                if (!dropsIntervalHandler) {
                    const fn = () => {
                        const randomColumn = Math.floor(Math.random() * (this.columnsCapacity + 1)),
                            minSpeed = 250, maxSpeed = 80,
                            randomSpeed = Math.floor(Math.random() * (maxSpeed - minSpeed + 1)) + minSpeed;

                        const list = [];
                        let line, offset;

                        if ($linesList) {
                            Array.from($linesList.querySelectorAll('li')).forEach($li => {
                                const text = $li.innerText.trim();
                                if (text.length > 0) {
                                    list.push(text);
                                }
                            });

                            if (list.length > 0 && Math.random() > 0.3) {
                                line = list[Math.floor(Math.random() * list.length)];
                                offset = Math.floor(Math.random() * line.length);
                                if (offset <= 5) offset *= 2;
                            }
                        }

                        drawLine(randomColumn, randomSpeed, line, offset);

                        if (dropsIntervalHandler) {
                            clearInterval(dropsIntervalHandler);
                            dropsIntervalHandler = undefined;
                        }

                        dropsIntervalHandler = setInterval(fn, ((minSpeed + maxSpeed) / 2 * this.rowsCapacity) / this.columnsCapacity / 0.6);
                    };
                    fn();
                }
            };

            if (typeof ResizeObserver === 'function') {
                (new ResizeObserver(this.init)).observe($canvas);
            } else {
                this.init();
            }
        };

        (new Matrix(document.getElementById('matrix'))).run(document.getElementById('matrix-words'));
    </script>
{{end}}
